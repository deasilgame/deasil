pub mod components;
mod systems;

use rand::random;

pub struct Game {
    pub clock: components::Clock,
    pub input: components::Input,
    pub camera: components::Camera,
    pub entities: Vec<Option<components::Entity>>,
}

impl Game {
    pub fn new() -> Self {
        Game {
            clock: components::Clock::default(),
            input: components::Input::default(),
            camera: components::Camera::default(),
            entities: vec![Some(create_player())],
        }
    }

    pub fn update(&mut self, dt: f64) {
        // andvance game clock
        self.clock.advance(dt);

        // update the world
        systems::process_input(self);
        systems::process_physics(self);

        // process events generated by systems
        // TODO

        // process async entity creation/deletion
        // self.world.maintain();
    }

    

    pub fn input_mut(&mut self) -> &mut components::Input {
        &mut self.input
    }

    pub fn player_mut(&mut self) -> &mut components::Entity {
        if let Some(ref mut player) = self.entities[0] {
            player
        } else {
            panic!("No player!");
        }
    }
}

pub fn create_dummy_entity(game: &mut Game) {
    // create a dummy "particle"
    const MAX_V: f64 = 20.0;
    game.entities.push(Some(components::Entity {
        position: components::Position(components::Point::new(0.0, 0.0)),
        rotation: components::Rotation::default(),
        velocity: components::Velocity::new(
            random_range(-MAX_V, MAX_V),
            random_range(-MAX_V, MAX_V),
        ),
        angular_velocity: components::AngularVelocity::new(random_range(-3.14, 3.14)),
        shape: random_shape(),
        acceleration: components::Acceleration::default(),
    }));
}

pub fn create_player() -> components::Entity {
    components::Entity {
        position: components::Position(components::Point::new(0.0, 0.0)),
        rotation: components::Rotation::default(),
        velocity: components::Velocity::default(),
        acceleration: components::Acceleration::default(),
        angular_velocity: components::AngularVelocity::default(),
        shape: player_shape(),
    }
}

fn random_range(from: f64, to: f64) -> f64 {
    from + (to - from) * random::<f64>()
}

const SHAPE_SIZE: f64 = 1.0;

fn player_shape() -> components::Shape {
    use self::components::Shape::*;
    use self::components::{SubShape, Vector};

    let mut subshapes = Vec::new();
    subshapes.push(SubShape {
        offset: Vector::new(0.0, 0.0),
        rotation: 0.0,
        shape: Circle(1.0),
    });
    subshapes.push(SubShape {
        offset: Vector::new(0.75, 0.0),
        rotation: 0.0,
        shape: Rectangle(Vector::new(0.75, 0.5)),
    });
    subshapes.push(SubShape {
        offset: Vector::new(-0.75, 0.75),
        rotation: 3.14 / 4.0,
        shape: Rectangle(Vector::new(0.5, 0.5)),
    });
    subshapes.push(SubShape {
        offset: Vector::new(-0.75, -0.75),
        rotation: 3.14 / 4.0,
        shape: Rectangle(Vector::new(0.5, 0.5)),
    });

    Compound(subshapes)
}

fn random_shape() -> components::Shape {
    use self::components::Shape::*;
    use self::components::{SubShape, Vector};

    match (random::<bool>(), random::<bool>()) {
        (true, true) => Circle(SHAPE_SIZE / 2.0),
        (true, false) => Rectangle(Vector {
            dx: SHAPE_SIZE,
            dy: SHAPE_SIZE,
        }),
        (false, true) => Sprite(
            "TODO".to_string(),
            Vector {
                dx: SHAPE_SIZE,
                dy: SHAPE_SIZE,
            },
        ),
        (false, false) => {
            let mut subshapes = Vec::new();
            for _ in 0..3 {
                subshapes.push(SubShape {
                    offset: Vector {
                        dx: random_range(-SHAPE_SIZE * 0.75, SHAPE_SIZE * 0.75),
                        dy: random_range(-SHAPE_SIZE * 0.75, SHAPE_SIZE * 0.75),
                    },
                    rotation: random_range(0.0, 3.14),
                    shape: random_shape(),
                })
            }
            Compound(subshapes)
        }
    }
}
