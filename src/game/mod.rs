pub mod components;
mod systems;

use rand::random;

use specs::*;
use specs::shred::{Resource, FetchMut};

pub struct Game<'a, 'b> {
    // ECS
    pub world: World,
    dispatcher: Dispatcher<'a, 'b>,

    // cursor position in window coords
    cursor_position: [f64; 2],
}

impl<'a, 'b> Game<'a, 'b> {
    pub fn new() -> Self {
        Game {
            world: components::create_world(),
            dispatcher: DispatcherBuilder::new()
                .with(systems::LinearMovementSys, "Linear Movement", &[])
                .with(systems::AngularMovementSys, "Angular Movement", &[])
                .build(),
            cursor_position: [0.0, 0.0],
        }
    }

    pub fn add_resource<T: Resource>(&mut self, resource: T) {
        self.world.add_resource(resource);
    }

    pub fn write_resource<T: Resource>(&self) -> FetchMut<T> {
        self.world.write_resource()
    }

    pub fn update(&mut self, dt: f64) {
        // andvance game clock
        (*self.world.write_resource::<components::Clock>()).advance(dt);

        // update the world
        self.dispatcher.dispatch(&self.world.res);

        // process events generated by systems
        // TODO

        // process async entity creation/deletion
        self.world.maintain();
    }

    pub fn render(&mut self, rendering_dispatcher: &mut Dispatcher) {
        rendering_dispatcher.dispatch(&self.world.res);
    }

    pub fn handle_mouse_move(&mut self, position: [f64; 2]) {
        // just store last cursor position
        self.cursor_position = position;
        (*self.world.write_resource::<components::Camera>()).center_at(components::Point::new(position[0], position[1]));
    }

    pub fn handle_mouse_left_click(&mut self) {
        // create a dummy "particle"
        const MAX_V: f64 = 20.0;
        self.world.create_entity()
            .with(components::Position(components::Point::new(0.0, 0.0)))
            .with(components::Rotation::default())
            .with(components::Velocity::new(random_range(-MAX_V, MAX_V), random_range(-MAX_V, MAX_V)))
            .with(components::AngularVelocity::new(random_range(-3.14, 3.14)))
            .with(random_shape())
            .build();
    }

    pub fn handle_mouse_y_scroll(&mut self, dy: f64) {
        (*self.world.write_resource::<components::Camera>()).adjust_zoom(super::consts::ZOOM_FACTOR.powf(dy));
    }
}

fn random_range(from: f64, to: f64) -> f64 {
    from + (to - from) * random::<f64>()
}

const SHAPE_SIZE: f64 = 10.0;

fn random_shape() -> components::Shape {
    use self::components::{SubShape, Vector};
    use self::components::Shape::*;

    match (random::<bool>(), random::<bool>()) {
        (true, true) => Circle(SHAPE_SIZE / 2.0),
        (true, false) => Rectangle(Vector { dx: SHAPE_SIZE, dy: SHAPE_SIZE }),
        (false, true) => Sprite("TODO".to_string(), Vector { dx: SHAPE_SIZE, dy: SHAPE_SIZE }),
        (false, false) => {
            let mut subshapes = Vec::new();
            for _ in 0..3 {
                subshapes.push(SubShape {
                    offset: Vector {
                        dx: random_range(-SHAPE_SIZE * 0.75, SHAPE_SIZE * 0.75),
                        dy: random_range(-SHAPE_SIZE * 0.75, SHAPE_SIZE * 0.75),
                    },
                    rotation: random_range(0.0, 3.14),
                    shape: random_shape(),
                })
            }
            Compound(subshapes)
        }
    }
}
