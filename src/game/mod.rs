pub mod components;
mod systems;

use rand::random;

use specs::*;
use specs::shred::{Resource, FetchMut};

pub struct Game<'a, 'b> {
    // ECS
    pub world: World,
    dispatcher: Dispatcher<'a, 'b>,

    // cursor position in window coords
    cursor_position: [f64; 2],
}

impl<'a, 'b> Game<'a, 'b> {
    pub fn new() -> Self {
        Game {
            world: components::create_world(),
            dispatcher: DispatcherBuilder::new()
                .with(systems::LinearMovementSys, "Linear Movement", &[])
                .with(systems::AngularMovementSys, "Angular Movement", &[])
                .build(),
            cursor_position: [0.0, 0.0],
        }
    }

    pub fn add_resource<T: Resource>(&mut self, resource: T) {
        self.world.add_resource(resource);
    }

    pub fn write_resource<T: Resource>(&self) -> FetchMut<T> {
        self.world.write_resource()
    }

    pub fn update(&mut self, dt: f64) {
        // andvance game clock
        (*self.world.write_resource::<components::Clock>()).advance(dt);

        // update the world
        self.dispatcher.dispatch(&self.world.res);

        // process events generated by systems
        // TODO

        // process async entity creation/deletion
        self.world.maintain();
    }

    pub fn render(&mut self, rendering_dispatcher: &mut Dispatcher) {
        rendering_dispatcher.dispatch(&self.world.res);
    }

    pub fn handle_mouse_move(&mut self, position: [f64; 2]) {
        // just store last cursor position
        self.cursor_position = position;
    }

    pub fn handle_mouse_left_click(&mut self) {
        // create a dummy "particle"
        const MAX_V: f64 = 20.0;
        self.world.create_entity()
            .with(components::Position {
                x: self.cursor_position[0],
                y: self.cursor_position[1],
            })
            .with(components::Velocity {
                x: random_range(-MAX_V, MAX_V),
                y: random_range(-MAX_V, MAX_V),
            })
            .build();
    }
}

fn random_range(from: f64, to: f64) -> f64 {
    from + (to - from) * random::<f64>()
}
